
use bevy::prelude::*;
use serde::{Deserialize, Serialize};
use crate::{
  character_library::CharacterLibrary,
  character::PlayerId,
  utils::countdown
};

/// Box generated by attacks in game
#[derive(Component,Debug, Clone, Copy)]
pub struct Hitbox {
  /// Attack level, effects hit/block stun
  attack_level: u8,
  /// Base damage of the hitbox
  damage: u8,
  /// Proration when this hitbox connects first in a combo
  proration: f32,
  /// Force to be applied when a player is hit by this
  force: Vec2,
  /// Has the hitbox connected
  hit_state: HitState,
  /// Can the hitbox be blocked in the air
  air_blockable: bool,
  /// The block property of the hitbox
  property: HitboxProperty,
  /// How many frames will this hitbox stay out
  duration: u8,
  /// Does this hitbox cause damage when blocked
  chip: bool,
  /// Is the hitbox currently active
  active: bool,
  /// Is the hitbox attached to the player that generated it
  projectile: bool,
}

impl Hitbox {
  /// Create a hitbox from it's serialized counterpart
  pub fn from_serialized(s: HitboxSerialized) -> Self {
    Hitbox {
      attack_level: s.attack_level,
      damage: s.damage,
      proration: s.proration,
      force: s.force.to_vec2(),
      air_blockable: s.air_blockable,
      property: s.property,
      duration: s.duration,
      chip: s.chip,
      projectile: s.projectile,
      hit_state: HitState::None,
      active: false
    }
  }

  /// if possible, lower the hitboxes duration by 1 frame
  pub fn tick(&mut self) {
    self.duration = countdown(self.duration);
  }

  /// return if the hitbox should be removed
  pub fn is_finished(&self) -> bool {
    return self.duration == 0;
  }

  pub fn generate_collision(&self, hurtbox: &Hurtbox) -> Collision {
    return Collision::new(self.clone(), self.is_blocked(hurtbox));
  }

  /// Returns if a Hitbox is blocked by a Hurtbox it overlaps
  pub fn is_blocked(&self, hurtbox: &Hurtbox) -> bool {
    use HitboxProperty::*;
    use BlockState::*;
    match hurtbox.block_state {
      Stand {barrier:_, instant:_} => {
        match self.property {
          Low => return false,
          _ => return true
        }
      },
      Crouch {barrier:_, instant:_} => {
        match self.property {
          High => return false,
          _ => return true
        }
      },
      Air {barrier, instant:_} => {
        if self.air_blockable {
          return true
        } else {
          if barrier {
            return true
          } else {
            return false
          }
        }
      },
      None => return false,
    }
  }
}


/// 
#[derive(Debug, Clone, Copy)]
pub struct HitboxEvent {
  /// The data that the created hitbox should carry
  pub hitbox: Hitbox,
  /// where should the hitbox be placed in relation to the player
  pub position: Vec2,
  /// size of the hitbox
  pub size: Vec2,
  /// what frame of the attack should the hitbox be generated
  pub frame: u8,
}



/// Serialized version of bevy's Vec2
#[derive(Deserialize, Serialize)]
pub struct Vec2Serialzed {
  pub x: f32,
  pub y: f32,
}

impl Vec2Serialzed {
  /// Convert a serialized Vec2 to a true Vec2
  pub fn to_vec2(&self) -> Vec2 {
    Vec2::new(self.x,self.y)
  }
}

impl HitboxEvent {
  /// Create a hitbox event from it's serialized counterpart
  pub fn from_serialized(s: HitboxEventSerialized, library: &CharacterLibrary, character_name: &str) -> Self {
    let hitbox = library.get_hitbox(format!("{}_{}",character_name,s.hitbox.clone())).unwrap();
    HitboxEvent {
      hitbox,
      position: s.position.to_vec2(),
      size: s.size.to_vec2(),
      frame: s.frame
    }
  }
}

pub struct HurtboxEvent {
  hurtbox_type: HurtboxType,
  /// Is the hurtbox collidable
  active: bool,
  /// Where should the hurtbox be placed
  position: Vec2,
  /// What size should the hurtbox change to
  size: Vec2,
}


#[derive(Debug, Clone, Copy)]
pub enum HitState {
  None,
  Hit,
  Blocked
}

#[derive(Debug, Clone, Copy)]
pub enum HurtboxType {
  Upper,
  Lower,
  Limb
}

/// How the attack must be blocked
#[derive(Deserialize, Serialize, Debug, Clone, Copy)]
pub enum HitboxProperty {
  Mid,
  Low,
  High,
}

/// Serialized version of an attack
#[derive(Deserialize, Serialize)]
pub struct AttackSerialized {
  pub name: String,
  pub hitbox_events: Vec<HitboxEventSerialized>,
  pub busy: u8,
}

/// Serialized version of a hitbox event
#[derive(Deserialize, Serialize)]
pub struct HitboxEventSerialized {
  pub hitbox: String,
  pub position: Vec2Serialzed,
  pub size: Vec2Serialzed,
  pub frame: u8,
}

/// Serialized version of a hitbox
#[derive(Deserialize, Serialize)]
pub struct HitboxSerialized {
  pub name: String,
  pub attack_level: u8,
  pub damage: u8,
  pub proration: f32,
  pub force: Vec2Serialzed,
  pub air_blockable: bool,
  pub property: HitboxProperty,
  pub duration: u8,
  pub chip: bool,
  pub projectile: bool,
}


/// Trait to implement a helper method on Commands to allow easily spawning hitboxes
pub trait SpawnHitbox {
  fn spawn_hitbox(&mut self, player_id: &PlayerId, hitbox_event: &HitboxEvent, parent_transform: &Transform, facing_vector: f32);
}

impl SpawnHitbox for Commands<'_, '_>{
  fn spawn_hitbox(&mut self, player_id: &PlayerId, hitbox_event: &HitboxEvent, parent_transform: &Transform, facing_vector: f32 ) {
    let offset = Vec3::new(hitbox_event.position.x * facing_vector, hitbox_event.position.y, 1.0);
    let parent_translation = parent_transform.translation;
    let transform = Transform::from_translation(parent_translation + offset);

    self.spawn_bundle( SpriteBundle {
      sprite: Sprite {
        color: Color::rgb(0.25, 0.25, 0.75),
        custom_size: Some(hitbox_event.size),
        ..Default::default()
      },
      transform,
      ..Default::default()
      }
    )
    .insert(player_id.clone())
    .insert(hitbox_event.hitbox);
  }
}


pub struct Hurtbox {
  pub is_grounded: bool,
  pub block_state: BlockState,
}


pub struct Collision {
  pub hitbox: Hitbox,
  pub blocked: bool,
}

impl Collision {
  pub fn new(hitbox: Hitbox, blocked: bool) -> Self {
    Collision {
      hitbox,
      blocked
    }
  }
}

pub struct CollisionEvent{
  pub collision: Collision,
  pub player_id: PlayerId,
  pub recieving_player_id: PlayerId,
}





#[derive(PartialEq, Clone, Copy)]
pub enum BlockState {
  Stand {barrier: bool, instant: bool},
  Air {barrier: bool, instant: bool},
  Crouch {barrier: bool, instant: bool},
  None
}

#[derive(PartialEq, Clone, Copy)]
pub enum BlockModifier {
  BARRIER,
  INSTANT,
}
